---
title: "Assign3"
format: 
  html:
    toc: true
---

# Setup

Some packages:
```{r}
#| label: packages
#| collapse: TRUE
library(dplyr)
library(ggplot2)
library(patchwork)
set_theme(theme_bw()) # for ggplot formatting
```

Now the data:
```{r}
#| label: load-data
#| collapse: TRUE
anpp <- read.csv('global_ANPP_data.csv', header = TRUE) |>
  select(-X) # get rid of "X" column that's an artifact of the file
str(anpp)
```

AF only has 3 observations; if we include region as a factor, we should exclude these data because there just aren't enough to make robust inference.

# EDA: variable distributions -- Q1 and 2

## Histograms

> note for Noah: the #| lines at the beginning of chunks aren't R code -- they're options for Quarto in knitting and evaluating chunks. #| label: xxxx means label this chunk xxxx for organization/future reference.

A histogram plotting function to avoid a ton of redundant code:

```{r}
#| label: plot-hist
# We use {{var}} so we can use dplyr-style data masking: from Hadley Wickham
#> "programming with dplyr" page

plot_hist <- function(data, 
                      var,
                      color = 'grey20',
                      fill = 'lightgrey',
                      fill_alpha = 0.75,
                      num_bins = 10,
                      add_mean = TRUE,
                      line_col = 'red',
                      line_type = 'dashed'){
  p <- ggplot(data)+
    geom_histogram(aes(x = {{var}}),
                   color = color,
                   fill = fill,
                   bins = num_bins)+
      labs(y = 'Count')
  

  if(add_mean == TRUE){
    p <- p+geom_vline(aes(xintercept = mean({{var}})),
                      color = line_col,
                      linetype = line_type)
  }   
  
  return(p)
}
```


And now let's use the code to make some histograms.

```{r}
#| label: histograms
#| 

# MAT
mat_hist <- plot_hist(data = anpp,
                      var = MAT)

# MAP
map_hist <- plot_hist(data = anpp,
                      var = MAP)


# ANPP
anpp_hist <- plot_hist(data = anpp,
                       var = ANPP)

# Now make a figure:
## Overall
mat_hist+map_hist+anpp_hist+plot_layout(axis_titles = 'collect')

```


## Scatterplots

Again, a function to save typing. Since we're going to be using a gamma distribution with a log link, let's examine linearity of predictors WRT log(ANPP) (though this behavior is customizable with the `yvar` option).

```{r}
plot_scatter <- function(data,
                         xvar,
                         yvar = log(ANPP),
                         pt_alpha = 0.5,
                         smooths = TRUE,
                         smooth_col = 'blue',
                         smooth_lty = 'dashed',
                         smooth_lty_rgn = 'solid'){
  
  # plot template
  p <- ggplot(data, aes(x = {{xvar}}, y = {{yvar}}))+
    geom_point(alpha = pt_alpha)
  
  if(smooths == TRUE){
    p <- p+geom_smooth(formula = y ~ x,
                method = 'loess',
                se = FALSE,
                col = smooth_col,
                linetype = smooth_lty)
  }
  return(p)
}
```

Using that function:

```{r}
#| label: scatterplots

# MAT
mat_scatter <- plot_scatter(anpp, xvar = MAT, smooth_lty = 'solid')


# MAP
map_scatter <- plot_scatter(anpp, xvar = MAP, smooth_lty = 'solid')



# Log MAP
log_map_scatter <- plot_scatter(anpp, xvar = log(MAP), smooth_lty = 'solid')


# Figures
## Overall
map_scatter+mat_scatter+plot_layout(axis_titles = 'collect') 


## Log vs untransformed
map_scatter+log_map_scatter+plot_layout(axis_titles = 'collect')

```


## Takeaways (Q3)

We can see a few things here:

1. ANPP is positive, continuous, and skewed (from the histogram)
2. ANPP variance is not constant with respect to MAT (from the scatterplot): higher MAT has higher variance (heteroskedacity)
3. ANPP is not linearly related to MAP.
4. MAP is not normally distributed; it is strictly positive and right-skewed. log(MAP) is much closer to normal.
5. MAT is closer to normally distributed, but it still has a sort of weird shape.
6. We recover a more linear relationship between log(MAP) and ANPP, but variance is still non-constant.

Taking 1 and 2 together, we should use either a Gamma or Inverse Gaussian distribution as the response distribution.

# Approach to modeling

We want to know:

1. Which distribution? Gamma or inverse gaussian?
2. Which combination of predictors?
  - Include interactions?
  - Transform predictors?
 
Gamma vs Inverse Gaussian: 
https://link.springer.com/chapter/10.1007/978-1-4419-0118-7_11 (found a pdf)
- Gamma has variance related to mean^2
- Inverse gaussian has variance related to mean^3
- We can figure this out by plotting log(variance) against log(means) and seeing whether the slope is closer to 2 or 3.
- Typically use inverse gaussian with really really severe skew, which I don't think we have. There's some code in the graveyard formalizing this, but Gamma is our best bet I think.

Because Gamma is best bet, we can just look at (2). I think we can start with a saturated model and look at leverage. Based on that, transform predictors and see if that helps with leverage. Then start paring down the model.



From the plots, we see that the residuals vs leverage plot and the scale-location plot actually look worse than the original full model.


# Modeling 

## Full Model

As always, we'll start by running a full model.
 
### Running the model

```{r}
m1 <- glm(ANPP ~ MAT*MAP,
          family = Gamma(link = 'log'),
          data = anpp)
```
### Diagnostics

```{r}
plot(m1)
```

We have some higher leverage points (but still within acceptable Cook's distance); let's see where these points fall on the distribution of MAT and MAP:

```{r}
#| label: leverage-points

m1_lev <- c(37, 38, 46)
m1_mat_lev <- anpp[m1_lev, 3]
m1_map_lev <- anpp[m1_lev, 4]

hist(anpp$MAT)
abline(v = m1_mat_lev, col = 'red')

hist(anpp$MAP)
abline(v = m1_map_lev, col = 'red')
```

We can see that, in fact, the high leverage points for MAP are on the tail end. So then we can log-transform the MAP data to get it better behaved:

```{r}
#| label: examine-leverage
hist(log(anpp$MAP))
abline(v = log(m1_map_lev), col = 'red')
```


While these points still fall on the tails, they may have less leverage now. Let's check:


```{r}
#| label: full-model-log
m1_log <- glm(ANPP ~ MAT*log(MAP),
                family = Gamma(link = 'log'),
                data = anpp)
plot(m1_log)
```

Leverage plot looks a lot better, but residuals are a bit wonky at the tail end of the CDF (Q-Q plot). Let's see if this model fits better than the un-logged one, using AIC:

```{r}
AIC(m1, m1_log)
```

Looks like, as we suspected from residuals, that m1_log is better.

We'll make a figure comparing the residuals vs fitted and cook's distance for both models.

```{r}

```


### ANOVA

Let's now look at an analysis of deviance to see if we can pare this model down.

```{r}
anova(m1_log, test = 'Chisq')
```

It looks like no: both terms and their interactions contribute significantly to decreasing the residual deviance. Because these models are nested, we don't even need to use AIC. But just to check, let's run a model that doesn't include the interaction term.

## Simplified Model 2

### Running the model

Let's remove the interaction term. If all is right in the world, our ANOVA and AIC results should agree.

```{r}
m2_log <- glm(ANPP ~ log(MAP)+MAT,
              family = Gamma(link = 'log'),
              data = anpp)
```

### Diagnostics

```{r}
plot(m2_log)
```

## Simplified model 3 and 4
This will be MAT only:

```{r}
m3_log <- glm(ANPP ~ MAT,
              family = Gamma(link = 'log'),
              data = anpp)
```

And MAP only:

```{r}
m4_log <- glm(ANPP ~ log(MAP),
              family = Gamma(link = 'log'),
              data = anpp)
```

Let's use AIC to compare this model to the full model. If all is right in the world, this will have a higher AIC (agreeing with the ANOVA results):

```{r}
AIC(m1_log, m2_log, m3_log, m4_log, m1) |>
  arrange(AIC)
```

These results are as expected.

# Coefficients

Now that we have selected our best-fitting model, let's look at the coefficients:

```{r}
summary(m1_log)
```
Plotting partial residuals:

```{r}
par(mfrow = c(1,2))
termplot(m1_log, data = anpp, partial.resid = TRUE)
```

# Transforming coefficients

First, some R setup:
```{r}
b0 <- m1_log$coefficients[1] # intercept
b1 <- m1_log$coefficients[2] # MAT
b2 <- m1_log$coefficients[3] # log(MAP)
b3 <- m1_log$coefficients[4] # interaction
```

Now some math. Our model formulation is:

$$
\log(\text{ANPP}) = \beta_0 + \beta_1 \text{MAT} + \beta_2 \log(\text{MAP})+\beta_3 \text{MAT}\log(\text{MAP})
$$

## MAT coefficient

Consider a 1-unit increase in MAT when log(MAP) is 0. Note $\beta_0 + \beta_2 \log(\text{MAP})+\beta_3 \text{MAT}\log(\text{MAP}) = \beta_0$.

$$
\log(\text{ANPP}_1) = \beta_0 + \beta_1 \text{MAT}\\
\log(\text{ANPP}_2) = \beta_0 + \beta_1 (\text{MAT}+1)
$$

\begin{align}
\implies \log(\text{ANPP}_2)-\log(\text{ANPP}_1) &= \beta_1 \\
\log(\frac{\text{ANPP}_2}{\text{ANPP}_1}) &= \beta_1 \\
\frac{\text{ANPP}_2}{\text{ANPP}_1} &= e^{\beta_1}
\end{align}

Calculating $e^{\beta_1}$:
```{r}
mat_coeff <- exp(b1)
mat_coeff
```
So a 1-unit increase in MAT means a 1.135x increase in ANPP, AKA a 14% increase.

## MAP coefficient

Consider a 10% increase in MAP when MAT is 0. Because MAT = 0, $\beta_0 + \beta_1 \text{MAT} +\beta_3 \text{MAT}\log(\text{MAP}) =  \beta_0$.

$$
\log(\text{ANPP}_1) = \beta_0 + \beta_2\log(\text{MAP}) \\
\log(\text{ANPP}_2) = \beta_0 + \beta_2\log(\text{1.1MAP})
$$

\begin{align}
\implies \log(\text{ANPP}_2)-\log(\text{ANPP}_1) &= \beta_2(\log(1.1\text{MAP})-\log(\text{MAP})) \\
\log(\frac{\text{ANPP}_2}{\text{ANPP}_1}) &= \beta_2(\log(\frac{1.1\text{MAP}}{\text{MAP}})) \\
&= \beta_2 \log(1.1)
\end{align} 

$\implies \frac{\text{ANPP}_2}{\text{ANPP}_1} = e^{\beta_2 \log(1.1)}$


Calculating $e^{\beta_2 \log(1.1)}$:
```{r}
map_coeff <- exp(b2*log(1.1))
map_coeff
```

So a 10% increase in MAP means a 1.03x increase in ANPP, AKA a 3% increase.

## Interaction

This one is the most involved. 

### MAT constant

Let's first consider the case where MAT is held constant. In this case, we're finding the contribution of MAP conditional on a value of MAT. Then:

$\log(\text{ANPP}_1) = \beta_0 + \beta_1 \text{MAT} + \beta_2 \log\text{MAP} + \beta_3 \text{MAT}\log(\text{MAP})$

$\log(\text{ANPP}_2) = \beta_0 + \beta_1 \text{MAT} + \beta_2 \log\text{1.1MAP} + \beta_3 \text{MAT}\log(\text{1.1MAP})$

\begin{align}
\implies \log(\text{ANPP}_2)-\log(\text{ANPP}_1) &= \beta_2(\log(1.1\text{MAP})-\log(\text{MAP})) + \beta_3(\text{MAT}\log(\text{1.1MAP})-\text{MAT}\log(\text{MAP})) \\
\log(\frac{\text{ANPP}_2}{\text{ANPP}_1}) &= \beta_2 \log(1.1) + \beta_3 \text{MAT}\log(1.1) 
\end{align}



\begin{align}
\implies \frac{\text{ANPP}_2}{\text{ANPP}_1} &= e^{\beta_2 \log(1.1) + \beta_3 \text{MAT}\log(1.1)} \\
&= e^{\beta_2\log(1.1)}*e^{\beta_3\log(1.1)\text{MAT}} \\
&= e^{\beta_2\log(1.1)}*\exp({\beta_3\log(1.1)})^{\text{MAT}}
\end{align}


The first part of this is identical to the effect of a 10% increase in MAP on ANPP. Let's calculate the second part:

```{r}
map_marginal <- exp(b3*log(1.1))
map_marginal
```

We can plot this marginal:

```{r}
mat_vals <- seq(min(anpp$MAT), max(anpp$MAT), length.out = 100)
plot(mat_vals, map_coeff*map_marginal^mat_vals,
     xlab = 'MAT value',
     ylab = 'Marginal effect of MAP|MAT',
     type = 'l')
```

### log(MAP) constant

Let's now consider the other case, with log(MAP) held constant:

$\log(\text{ANPP}_1) = \beta_0 + \beta_1 \text{MAT} + \beta_2 \log\text{MAP} + \beta_3 \text{MAT}\log(\text{MAP})$

$\log(\text{ANPP}_2) = \beta_0 + \beta_1 \text{MAT+1} + \beta_2 \log\text{MAP} + \beta_3 \text{(MAT+1)}\log(\text{MAP})$

\begin{align}
\implies \log(\text{ANPP}_2)-\log(\text{ANPP}_1) &= \beta_1(\text{MAT}+1-\text{MAT}) + \beta_3 ((\text{MAT+1})\log(\text{MAP})- \text{MAT}\log(\text{MAP})) \\
&= \beta_1 + \beta_3\log(\text{MAP}) 
\end{align}

\begin{align}
\implies \frac{\text{ANPP}_2}{\text{ANPP}_1} &= e^{\beta_1 + \beta_3 \log\text{MAP}} \\
&= e^{\beta_1}*e^{\beta_3\log\text{MAP}} \\
&= e^{\beta_1} \exp(\beta_3)^\text{MAP}
\end{align}

Similarly, note that the first term here is identical to the transformed coefficient for MAT. Let's calculate the second part:

```{r}
mat_marginal <- exp(b3)
mat_marginal
```

And again, we can plot this marginal effect:

```{r}
map_vals <- seq(min(anpp$MAP), max(anpp$MAP), length.out = 100)
plot(map_vals, mat_coeff*mat_marginal^mat_vals, type = 'l',
     xlab = 'MAP value',
     ylab = 'Marginal effect of MAT|MAP')
```

